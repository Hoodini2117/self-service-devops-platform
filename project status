Date: 2026-01-12
Project: Self-Service DevOps Platform
Phase: Phase 1 â€“ Manual Deployment

ğŸ§© Objective for the day

Get the Next.js e-commerce application running locally and inside Docker as the foundation for cloud deployment.

âœ… What I completed today

Selected a real production-grade app (Next.js e-commerce with Stripe & Sanity)

Installed and fixed project dependencies

Fixed npm peer-dependency conflicts

Pinned correct versions of:

React (18.2.0)

React-DOM (18.2.0)

Next.js (13.x)

Successfully ran the app locally (npm run dev)

Created a production-grade multi-stage Dockerfile

Built a Docker image using Node 20

Ran the app successfully inside a Docker container

ğŸ’¥ What broke
Problem	What happened
npm install failed	Peer-dependency conflicts between Sanity packages
Next.js app crashed	New React & Next versions were incompatible with the old project
Docker build failed	Node 18 did not meet Next.js version requirement
Dev server vs prod	npm run dev works locally but cannot be used in containers
ğŸ”§ How I fixed it
Problem	Fix
npm dependency conflict	Used npm install --legacy-peer-deps
React & Next mismatch	Forced React 18 and Next 13
Docker build error	Switched base image to node:20-alpine
Dev vs prod mismatch	Used npm run build + npm start in Docker
ğŸ§  What I learned today

Modern JavaScript apps break easily when versions are not pinned

npm installs newer incompatible versions by default

Containers freeze runtime versions and prevent CI/CD failures

Next.js must be built before running in production

Docker multi-stage builds produce smaller, cleaner images

ğŸ§± Current State of Project

The application is now:

âœ” Running locally

Day 2 â€” Cloud & Kubernetes (Real DevOps)

(Today)

ğŸ¯ Goal

Turn that Docker app into a real cloud-hosted production service.

â˜ï¸ Infrastructure (Terraform)

You built Azure infrastructure using Terraform:

Azure Resource Group

Azure Container Registry (ACR)

Azure Kubernetes Service (AKS)

You debugged:

Empty Terraform state

Wrong Azure subscription

Azure provider registration

Invalid VM size for your subscription

You successfully created:

A real Kubernetes cluster using Infrastructure as Code

ğŸ³ Containers â†’ Cloud

You:

Logged Docker into Azure

Tagged and pushed your image to ACR

Learned:

Cloud cannot see your laptop

Images must live in registries

â˜¸ï¸ Kubernetes

You created:

Namespace (ecommerce)

Deployment (2 replicas)

Service

NGINX Ingress Controller

Ingress

You connected:

Azure Load Balancer â†’ NGINX â†’ Service â†’ Pods


You now have a real public IP:

50.85.7.129


This is production-grade cloud networking.

ğŸ§  What broke today
Problem	What it taught you
Terraform said 0 resources	State â‰  Cloud
AKS not visible	Subscription mismatch
VM size rejected	Azure quotas & regions
ACR empty	You must push images
App unreachable	Containers binding to localhost
Next.js blocking	Reverse proxy security
Ingress weirdness	Real production routing rules
Campus Wi-Fi blocks IP	Real world network security
ğŸ§© What you now have

You have built:

Any app
   â†’ Docker
   â†’ Azure Container Registry
   â†’ Azure Kubernetes Service
   â†’ NGINX Ingress
   â†’ Public Internet


This is the core engine of your future:

Self-Service DevOps Platform

ğŸ§­ Where you stopped

The platform works.
The app runs.
The only remaining blocker is external network filtering (college Wi-Fi).

Next session you will:

Test from another network

Add Domain + HTTPS

Add CI/CD

Convert this into a true self-service system
âœ” Running inside Docker
âŒ Not yet in Azure
âŒ Not yet on Kubernetes
